;; (defun game-over? (board symbol)
;;   (or (and (eq (aref board 0 0) symbol) (eq (aref board 0 1) symbol) (eq (aref board 0 2) symbol)) 
;;       (and (eq (aref board 1 0) symbol) (eq (aref board 1 1) symbol) (eq (aref board 1 2) symbol)) 
;;       (and (eq (aref board 2 0) symbol) (eq (aref board 2 1) symbol) (eq (aref board 2 2) symbol)) 
;;       (and (eq (aref board 0 0) symbol) (eq (aref board 1 0) symbol) (eq (aref board 2 0) symbol)) 
;;       (and (eq (aref board 0 1) symbol) (eq (aref board 1 1) symbol) (eq (aref board 2 1) symbol))
;;       (and (eq (aref board 0 2) symbol) (eq (aref board 1 2) symbol) (eq (aref board 2 2) symbol))
;;       (and (eq (aref board 0 0) symbol) (eq (aref board 1 1) symbol) (eq (aref board 2 2) symbol))
;;       (and (eq (aref board 0 2) symbol) (eq (aref board 1 1) symbol) (eq (aref board 2 0) symbol))))

(defun game-over? (board symbol)
  (let ((x (array-dimension board 0))
        (y (array-dimension board 1))
        (i 0)
        (j 0)
        (done? nil)
        (temp? t))
    (loop until (or (= i x) done?)
          do (loop until (or (= j y) (not temp?))
                   do (if (not (eq (aref board i j) symbol))
                          (setf temp? nil))
                      (incf j))
             (if temp?
                 (setf done? t)
               (progn (setf temp? t)
                      ;; (format t "None on x = ~a" i)
                      (setf j 0)
                      (incf i))))
    (if (not done?)
        (progn
          (setf i 0)
          (setf j 0)
          (loop until (or (= j y) done?)
                do (loop until (or (= i x) (not temp?))
                         do (if (not (eq (aref board i j) symbol))
                                     (setf temp? nil))
                         (incf i))
                (if temp?
                    (setf done? t)
                  (progn (setf temp? t)
                         ;; (format t "None on y = ~a" j)
                         (setf i 0)
                         (incf j))))))
    (if (and (not done?) (= x y))
        (progn
          (setf i 0)
          (loop until (or (= i x) (not temp?))
                do (if (not (eq (aref board i i) symbol))
                       (setf temp? nil))
                   (incf i))
          (if temp?
              (setf done? t)
            (setf temp? t))))
    (if (and (not done?) (= x y))
        (progn
          (setf i 0)
          (loop until (or (= i x) (not temp?))
                do (if (not (eq (aref board i (- (- x i) 1)) symbol))
                       (setf temp? nil))
                   (incf i))
          (if temp?
              (setf done? t)
            (setf temp? t))))
    done?))
    

;; (defun game-over-cats? (board)
;;   (and (or (eq (aref board 0 0) 'O) (eq (aref board 0 0) 'X))
;;        (or (eq (aref board 0 1) 'O) (eq (aref board 0 1) 'X))
;;        (or (eq (aref board 0 2) 'O) (eq (aref board 0 2) 'X))
;;        (or (eq (aref board 1 0) 'O) (eq (aref board 1 0) 'X))
;;        (or (eq (aref board 1 1) 'O) (eq (aref board 1 1) 'X))
;;        (or (eq (aref board 1 2) 'O) (eq (aref board 1 2) 'X))
;;        (or (eq (aref board 2 0) 'O) (eq (aref board 2 0) 'X))
;;        (or (eq (aref board 2 1) 'O) (eq (aref board 2 1) 'X))
;;        (or (eq (aref board 2 2) 'O) (eq (aref board 2 2) 'X))))

(defun game-over-cats? (board)
  (let ((x (array-dimension board 0))
        (y (array-dimension board 1))
        (i 0)
        (j 0)
        (done? t))
    (loop until (= i x)
          do (loop until (= j y)
                   do (if (eq (aref board i j) 0)
                          (setf done? nil))
                      (incf j))
             (incf i)
             (setf j 0))
    done?))

(defun game-over-all? (board)
  (or (game-over? board 1)
      (game-over? board 2)
      (game-over-cats? board)))

(defun move (player symbol board formats symbol-hash)
  (format formats "~a's turn~%Enter horizontal cordinate: "
    player)
  (let ((horiz (read)))
    (format t "Enter vertical cordinate: ")
    (let ((vert (read)))
      (if (legal-move? horiz vert board)
          (set-board-after-move symbol board (- horiz 1) (- vert 1) formats symbol-hash)
        (progn (format formats "Illegal move. Try again.~%")
          (move player symbol board formats symbol-hash))))))
        
        
(defun render-board (board hash formats)
  (let ((x (- (array-dimension board 0) 1))
        (y (- (array-dimension board 1) 1))
        (i 0)
        (j 0))
    (loop
     do (loop 
         do (format formats "~a" (gethash (aref board i j) hash))
         until (= j y)
         do (format formats " | ")
            (incf j))
     until (= i x)
     do (format formats "~%---------~%")
        (setf j 0)
        (incf i)))
  (format formats "~%"))

(defun set-board-after-move (symbol board horiz vert formats symbol-hash) 
  (setf (aref board vert horiz) symbol)
    ;; (format formats "~a | ~a | ~a~%---------~%~a | ~a | ~a~%---------~%~a | ~a | ~a~%"
    ;;   (aref board 0 0)
    ;;   (aref board 0 1)
    ;;   (aref board 0 2)
    ;;   (aref board 1 0)
    ;;   (aref board 1 1)
    ;;   (aref board 1 2)
    ;;   (aref board 2 0)
    ;;   (aref board 2 1)
    ;;   (aref board 2 2))))
  (render-board board symbol-hash formats))
             
(defun play (&key (player1 "Player 1")
                  (player2 "Player 2")
                  (p1-type 'human)
                  (p2-type 'human)
                  (p1-symbol 'X)
                  (p2-symbol 'O)
                  (blank-symbol " ")
                  (formats t))
  (let ((board (make-array '(3 3) :initial-element 0))
        (symbol-hash (make-hash-table)))
    (setf (gethash 0 symbol-hash) blank-symbol)
    (setf (gethash 1 symbol-hash) p1-symbol)
    (setf (gethash 2 symbol-hash) p2-symbol)
    (loop until (game-over-all? board)
          do (case p1-type
               (ai
                (format formats "I'm thinking...~%")
                (let ((ai-move (second (min-max-value board t nil))))
                  (move-ai player1 1 board ai-move formats symbol-hash)))
               (sum
                (format formats "I'm thinking...~%")
                (let ((ai-move (second (min-max-value board t t))))
                  (move-ai player1 1 board ai-move formats symbol-hash)))
               (rand
                (format formats "I'm thinking...~%")
                (move-rand player1 1 board formats symbol-hash))
               (human
                (move player1 1 board formats symbol-hash))
               (otherwise
                (format t "\"~a\" is not a valid player type. Way to go.~%" p1-type)
                (return)))
          until (game-over-all? board)
          do (case p2-type
               (ai
                (format formats "I'm thinking...~%")
                (let ((ai-move (second (min-max-value board nil nil))))
                  (move-ai player1 2 board ai-move formats symbol-hash)))
               (sum
                (format formats "I'm thinking...~%")
                (let ((ai-move (second (min-max-value board nil t))))
                  (move-ai player1 2 board ai-move formats symbol-hash)))
               (rand
                (format formats "I'm thinking...~%")
                (move-rand player1 2 board formats symbol-hash))
               (human
                (move player1 2 board formats symbol-hash))
               (otherwise
                (format t "\"~a\" is not a valid player type. Way to go.~%" p2-type)
                (return)))
          until (game-over-all? board))
    (if (game-over? board 1)
        (progn (format t "~a wins!~%"
		       player1) 1)
      (if (game-over? board 2)
          (progn (format t "~a wins!~%"
			 player2) 2)
        (if (game-over-cats? board)
            (progn (format t "It's a cat's game! No one wins!~%") nil)
          (progn
            (format t "Something's wrong. I've hit an end state with no winner!~%Here's a friendly (break).~%")
            (break "End state found but no winner awarded.")))))))

(defun legal-move? (horiz vert board)
  (if (or (not (numberp vert))
          (not (numberp horiz))
          (> horiz 3)
          (> vert 3)
          (< horiz 1)
          (< vert 1)
          (eq (aref board (- vert 1) (- horiz 1)) 1)
          (eq (aref board (- vert 1) (- horiz 1)) 2))
      nil
    t))


;; todo: add Î±Î² trimming
(DEFUN min-max-value (board max? sum?)
  (if (game-over-all? board)
      (if (game-over-mm? board t)
          (list 1 nil 1)
        (if (game-over-mm? board nil)
            (list -1 nil -1)
          (list 0 nil 0)))
    (let ((best-move nil)
          (best-value (if sum? (if max? -9 9) (if max? -2 2)))
          (moves (get-moves board))
          (sum 0))
      (dolist (move moves)
        (play-move board move (if max? 1 2))
        (let* ((move-info (min-max-value board (not max?) sum?))
               (move-value (first move-info)))
          (if sum?
              (progn (setf sum (+ sum (third move-info)))
                     (when (or (and (= move-value best-value) (= (random 2) 0))
                               (funcall (if max? #'> #'<) move-value best-value))
                       (setf best-value move-value)
                       (setf best-move move)))
            (when (or (and (= move-value best-value) (= (random 2) 0))
                      (funcall (if max? #'> #'<) move-value best-value))
              (setf best-value move-value)
              (setf best-move move)))
          (undo-move board move)))
      (list best-value best-move sum))))

(defun game-over-mm? (board max?)
  (if max?
      (game-over? board 1)
    (game-over? board 2)))

(defun move-ai (player symbol board move formats symbol-hash)
  (let ((horiz (first move))
        (vert (second move)))
  (format formats "~a (CPU) played (~a,~a).~%"
    player (+ 1 horiz) (+ 1 vert))
      (if (legal-move? (+ 1 horiz) (+ 1 vert) board)
          (set-board-after-move symbol board horiz vert formats symbol-hash)
        (format formats "Illegal move. Try again.~%"))))

(defun move-rand (player symbol board formats symbol-hash)
  (let ((horiz (random 3))
        (vert (random 3)))
    (format formats "~a plays (~a,~a)~%"
      player (+ 1 horiz) (+ 1 vert))
    (if (legal-move? (+ 1 horiz) (+ 1 vert) board)
        (set-board-after-move symbol board horiz vert formats symbol-hash)
      (progn (format formats "Illegal move. Try again.~%")
        (move-rand player symbol board formats symbol-hash)))))

(defun play-move (board move symbol)
  (let ((horiz (first move))
        (vert (second move)))
    (setf (aref board vert horiz) symbol)))

(defun undo-move (board move)
  (let ((horiz (first move))
        (vert (second move)))
    (setf (aref board vert horiz) 0)))
  
(defun get-moves (board)
  (let ((possible-moves nil))
    (dotimes (horiz 3)
      (dotimes (vert 3)
        (if (not (or (eq (aref board vert horiz) 2)
                     (eq (aref board vert horiz) 1)))
            (push (list horiz vert) possible-moves))))
    possible-moves))

(defun move-value (move board)
  (aref board (second move) (first move)))

(defun lots-smart (num-games &key (p1-type 'ai)
                                  (p2-type 'ai))
  (let ((p1-wins 0)
        (p2-wins 0)
        (cat-wins 0)
        (games-left num-games))
    (loop until (= games-left 0)
        do (let ((winner (play :p1-type p1-type :p2-type p2-type :formats nil)))
             (if (and (numberp winner) (= winner 1))
                 (incf p1-wins)
               (if (and (numberp winner) (= winner 2))
                   (incf p2-wins)
                 (incf cat-wins))))
          (decf games-left))
    (format t "Computer Player 1 = ~a%~%Computer Player 2 = ~a%~%Cat = ~a%~%"
      (* 100.00 (/ p1-wins num-games)) (* 100.00 (/ p2-wins num-games)) (* 100.00 (/ cat-wins num-games)))))
